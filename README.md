# DailyNote


---

## Table of Contents

- [What is it?](#what-is-it)

- [Github note](#github-note)

I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.
I'm following this plan to prepare for my Google interview. I've been building the web, building services, and launching startups since 1997. I have an economics degree, not a CS degree. I've been very successful in my career, but I want to work at Google. I want to progress into larger systems and get a real understanding of computer systems, algorithmic efficiency, data structure performance, low-level languages, and how it all works. And if you don't know any of it, Google won't hire you.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

When I started this project, I didn't know a stack from a heap, didn't know Big-O anything, anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it wouldn't have been very good. Every data structure I've ever used was built into the language, and I didn't know how they worked under the hood at all. I've never had to manage memory, unless a process I was running would give an "out of memory" error, and then I'd have to find a workaround. I've used a few multi-dimensional arrays in my life and thousands of associative arrays, but I've never created data structures from scratch.

But after going through this study plan I have high confidence I'll be hired. It's a long plan. It's going to take me months. If you are familiar with a lot of this already it will take you a lot less time.

---
## Github note
	Test


## What is it?

This is my multi-month study plan for going from web developer (self-taught, no CS degree) to Google software engineer.

![Coding at the whiteboard - from HBO's Silicon Valley](https://dng5l3qzreal6.cloudfront.net/2016/Aug/coding_board_small-1470866369118.jpg)

This long list has been extracted and expanded from **Google's coaching notes**, so these are the things you need to know. 
There are extra items I added at the bottom that may come up in the interview or be helpful in solving a problem. Many items are from 
Steve Yegge's "[Get that job at Google](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)" and are reflected 
sometimes word-for-word in Google's coaching notes.

11111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
1111111111111111111111111111111111111111

11111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
1111111111111111111111111111111111111111

11111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
111111111111111111111
11111111111111111111111111111
1111111111111111111111111111111111111111


